# vue 面试题

1. v-model 实现原理

2. $nexttick （vue是异步渲染的，data改变之后，dom并不会立刻渲染）

3. slot

4. keep-alive 与 动态组件

5. mixin

```
组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

Mixins：在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件
```

6. v-if 与 v-for （v-for的优先级更高）

7. v-if 与 v-show 

   + 应用: ( Tree组件，显示隐藏用 v-show，是否展示用 v-if )

   + v-if 不会渲染，v-show 用 display 控制显示隐藏

8. computed 计算属性，缓存计算结果；（函数缓存）

9. computed 适用一个数据被多个数据影响(fullName)，而watch适用一个数据影响多个数据(监视route变化)

10. provide 与 inject

11. vuex 中的数据要传递给 computed,而不能直接赋值给 data，否则不会响应式

12. provide与inject传值时,provide传递的值,如果不是引用类型,就不会响应变化

13. data为什么是一个函数？

   + 因为 .vue 组件编译完之后 其实是一个类，每次使用的时候都是类实例化，data是一个函数就可以实现闭包

14. 何时使用 beforeDestory ? 

   + 解绑自定义事件 event.$off

   + 清除定时器

   + 解绑自定义的 dom事件，如 window scroll  

15. vuex 忠 mutation 与 action 的区别

   + action 可以进行异步操作

   + mutation 做原子操作，action 可以整合多个 mutation

16. key 的作用

   + diff 算法中通过 tag 和 key 来判断 是否是sameNode

   + v-for默认使用就地复用策略，列表数据修改的时候，他会根据key值去判断某项是否修改，如果修改，则重新渲染这一项，否则复用之前的元素

   + vue会对oldnode和newnode进行对比，发现两者key值是否相同，再进行调换位置或是删除操作


# watch 和 computed

### 计算属性computed : 

   - 支持缓存，只有依赖数据发生改变，才会重新进行计算
   - 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
   - computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
   - 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
   - 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法

### 侦听属性watch：

   - 不支持缓存，数据变，直接会触发相应的操作；
   - watch支持异步；
   - 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
   - 当一个属性发生变化时，需要执行对应的操作；一对多；
   - 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
　　immediate：组件加载立即触发回调函数执行，
　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到
  
 > 当需要在数据变化时执行异步或开销较大的操作时，watch是最有用的















# composition Api的优势

1. 可以将同一业务的代码放在一起，而不是分散到各个地方，更加灵活

2. 将相同业务的代码放在一起易于维护，类似于模块化思想，使用修改和删除都比较方便

3. vue3.0 实现了按需导入，更好的支持 tree shanking, 打包只需将引入的模块打包即可，其他未引入的模块会被删掉；

4. 自定义 hooks 使复用逻辑变得更加容易，mixin有很多弊端（代码不知从何处来，类型判断不准确，互相覆盖）

5. 更好的类型判断，对于函数来说，相同的输入有相同的输出；间接更好的支持了ts；